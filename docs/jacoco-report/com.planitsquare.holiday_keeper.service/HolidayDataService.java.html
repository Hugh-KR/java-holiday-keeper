<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HolidayDataService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">holiday-keeper</a> &gt; <a href="index.source.html" class="el_package">com.planitsquare.holiday_keeper.service</a> &gt; <span class="el_source">HolidayDataService.java</span></div><h1>HolidayDataService.java</h1><pre class="source lang-java linenums">package com.planitsquare.holiday_keeper.service;

import static com.planitsquare.holiday_keeper.constants.LogMessage.LOAD_ALL_COMPLETED;
import static com.planitsquare.holiday_keeper.constants.LogMessage.LOAD_ALL_START;
import static com.planitsquare.holiday_keeper.constants.LogMessage.LOAD_HOLIDAYS_COMPLETED;
import static com.planitsquare.holiday_keeper.constants.LogMessage.LOAD_HOLIDAYS_EMPTY;
import static com.planitsquare.holiday_keeper.constants.LogMessage.LOAD_HOLIDAYS_FAILED;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.planitsquare.holiday_keeper.constants.HolidayType;
import com.planitsquare.holiday_keeper.domain.entity.Country;
import com.planitsquare.holiday_keeper.domain.entity.PublicHoliday;
import com.planitsquare.holiday_keeper.domain.repository.HolidayRepository;
import com.planitsquare.holiday_keeper.external.client.NagerDateClient;
import com.planitsquare.holiday_keeper.external.dto.NagerHolidayResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

<span class="fc" id="L27">@Slf4j</span>
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class HolidayDataService {

    private final NagerDateClient nagerDateClient;
    private final HolidayRepository holidayRepository;
    private final CountryService countryService;

    @Value(&quot;${holiday.data.start-year}&quot;)
    private Integer startYear;

    @Value(&quot;${holiday.data.end-year}&quot;)
    private Integer endYear;

    @Transactional
    public Integer loadAllHolidays() {
<span class="fc" id="L45">        log.info(LOAD_ALL_START.getMessage(), startYear, endYear);</span>

<span class="fc" id="L47">        final List&lt;Country&gt; countries = countryService.fetchAndSaveAllCountries();</span>
<span class="fc" id="L48">        final Integer totalLoaded = loadHolidaysForAllCountriesAndYears(countries);</span>

<span class="fc" id="L50">        log.info(LOAD_ALL_COMPLETED.getMessage(), totalLoaded);</span>
<span class="fc" id="L51">        return totalLoaded;</span>
    }

    @Transactional
    public Integer loadHolidaysForYearAndCountry(final Integer year, final String countryCode,
            final Country country) {
<span class="fc" id="L57">        final List&lt;NagerHolidayResponse&gt; holidays =</span>
<span class="fc" id="L58">                nagerDateClient.getPublicHolidays(year, countryCode);</span>

<span class="fc bfc" id="L60" title="All 2 branches covered.">        if (holidays.isEmpty()) {</span>
<span class="fc" id="L61">            log.warn(LOAD_HOLIDAYS_EMPTY.getMessage(), year, countryCode);</span>
<span class="fc" id="L62">            return 0;</span>
        }

<span class="fc" id="L65">        final Integer savedCount = upsertHolidays(holidays, year, countryCode, country);</span>

<span class="fc" id="L67">        log.info(LOAD_HOLIDAYS_COMPLETED.getMessage(), year, countryCode, savedCount);</span>
<span class="fc" id="L68">        return savedCount;</span>
    }

    @Transactional
    public void deleteHolidays(final Integer year, final String countryCode) {
<span class="fc" id="L73">        countryService.validateCountryExists(countryCode);</span>
<span class="fc" id="L74">        deleteExistingHolidays(countryCode, year);</span>
<span class="fc" id="L75">    }</span>

    private Integer loadHolidaysForAllCountriesAndYears(final List&lt;Country&gt; countries) {
<span class="fc" id="L78">        return countries.stream().mapToInt(this::loadHolidaysForCountry).sum();</span>
    }

    private Integer loadHolidaysForCountry(final Country country) {
<span class="fc" id="L82">        final String countryCode = country.getCountryCode();</span>
<span class="fc" id="L83">        return IntStream.rangeClosed(startYear, endYear)</span>
<span class="fc" id="L84">                .map(year -&gt; loadHolidaysForSingleYear(year, countryCode, country)).sum();</span>
    }

    private Integer loadHolidaysForSingleYear(final Integer year, final String countryCode,
            final Country country) {
        try {
<span class="fc" id="L90">            final Integer loaded = loadHolidaysForYearAndCountry(year, countryCode, country);</span>
<span class="fc" id="L91">            log.debug(LOAD_HOLIDAYS_COMPLETED.getMessage(), year, countryCode, loaded);</span>
<span class="fc" id="L92">            return loaded;</span>
<span class="nc" id="L93">        } catch (final RuntimeException e) {</span>
<span class="nc" id="L94">            log.error(LOAD_HOLIDAYS_FAILED.getMessage(), year, countryCode, e.getMessage());</span>
<span class="nc" id="L95">            return 0;</span>
        }
    }

    private void deleteExistingHolidays(final String countryCode, final Integer year) {
<span class="fc" id="L100">        holidayRepository.deleteByCountryCodeAndYear(countryCode, year);</span>
<span class="fc" id="L101">    }</span>

    private Integer upsertHolidays(final List&lt;NagerHolidayResponse&gt; holidays, final Integer year,
            final String countryCode, final Country country) {
<span class="fc" id="L105">        final Map&lt;LocalDate, PublicHoliday&gt; existingHolidaysMap =</span>
<span class="fc" id="L106">                buildExistingHolidaysMap(countryCode, year);</span>
<span class="fc" id="L107">        final Set&lt;LocalDate&gt; newHolidayDates = extractHolidayDates(holidays);</span>
<span class="fc" id="L108">        final List&lt;PublicHoliday&gt; holidaysToSave =</span>
<span class="fc" id="L109">                processHolidays(holidays, year, countryCode, country, existingHolidaysMap);</span>

<span class="fc" id="L111">        deleteRemovedHolidays(existingHolidaysMap, newHolidayDates);</span>

<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (!holidaysToSave.isEmpty()) {</span>
<span class="fc" id="L114">            holidayRepository.saveAll(holidaysToSave);</span>
        }

<span class="fc" id="L117">        return holidaysToSave.size();</span>
    }

    private Map&lt;LocalDate, PublicHoliday&gt; buildExistingHolidaysMap(final String countryCode,
            final Integer year) {
<span class="fc" id="L122">        return holidayRepository.findByCountryCodeAndYear(countryCode, year).stream()</span>
<span class="pc" id="L123">                .collect(Collectors.toMap(PublicHoliday::getDate, holiday -&gt; holiday));</span>
    }

    private Set&lt;LocalDate&gt; extractHolidayDates(final List&lt;NagerHolidayResponse&gt; holidays) {
<span class="fc" id="L127">        return holidays.stream().map(NagerHolidayResponse::date).collect(Collectors.toSet());</span>
    }

    private void deleteRemovedHolidays(final Map&lt;LocalDate, PublicHoliday&gt; existingHolidaysMap,
            final Set&lt;LocalDate&gt; newHolidayDates) {
<span class="fc" id="L132">        final List&lt;PublicHoliday&gt; holidaysToDelete = existingHolidaysMap.values().stream()</span>
<span class="pc bnc" id="L133" title="All 2 branches missed.">                .filter(holiday -&gt; !newHolidayDates.contains(holiday.getDate())).toList();</span>

<span class="pc bpc" id="L135" title="1 of 2 branches missed.">        if (!holidaysToDelete.isEmpty()) {</span>
<span class="nc" id="L136">            holidayRepository.deleteAll(holidaysToDelete);</span>
        }
<span class="fc" id="L138">    }</span>

    private List&lt;PublicHoliday&gt; processHolidays(final List&lt;NagerHolidayResponse&gt; holidays,
            final Integer year, final String countryCode, final Country country,
            final Map&lt;LocalDate, PublicHoliday&gt; existingHolidaysMap) {
<span class="fc" id="L143">        final List&lt;PublicHoliday&gt; holidaysToSave = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L145" title="All 2 branches covered.">        for (final NagerHolidayResponse response : holidays) {</span>
<span class="fc" id="L146">            final PublicHoliday existingHoliday = existingHolidaysMap.get(response.date());</span>

<span class="pc bpc" id="L148" title="1 of 2 branches missed.">            if (existingHoliday != null) {</span>
<span class="nc" id="L149">                final PublicHoliday updatedHoliday =</span>
<span class="nc" id="L150">                        convertToEntity(response, year, countryCode, country);</span>
<span class="nc" id="L151">                existingHoliday.updateFrom(updatedHoliday);</span>
<span class="nc" id="L152">                holidaysToSave.add(existingHoliday);</span>
<span class="nc" id="L153">            } else {</span>
<span class="fc" id="L154">                final PublicHoliday newHoliday =</span>
<span class="fc" id="L155">                        convertToEntity(response, year, countryCode, country);</span>
<span class="fc" id="L156">                holidaysToSave.add(newHoliday);</span>
            }
<span class="fc" id="L158">        }</span>

<span class="fc" id="L160">        return holidaysToSave;</span>
    }

    private PublicHoliday convertToEntity(final NagerHolidayResponse response, final Integer year,
            final String countryCode, final Country country) {
<span class="fc" id="L165">        return PublicHoliday.builder().country(country).year(year).date(response.date())</span>
<span class="fc" id="L166">                .name(response.name()).localName(response.localName()).countryCode(countryCode)</span>
<span class="fc" id="L167">                .types(extractTypes(response)).fixed(extractFixed(response))</span>
<span class="fc" id="L168">                .global(extractGlobal(response)).launchYear(extractLaunchYear(response)).build();</span>
    }

    private String extractTypes(final NagerHolidayResponse response) {
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        return response.types() != null ? String.join(&quot;,&quot;, response.types())</span>
<span class="nc" id="L173">                : HolidayType.getDefaultValue();</span>
    }

    private boolean extractFixed(final NagerHolidayResponse response) {
<span class="fc" id="L177">        return extractBooleanOrDefault(response.fixed());</span>
    }

    private boolean extractGlobal(final NagerHolidayResponse response) {
<span class="fc" id="L181">        return extractBooleanOrDefault(response.global());</span>
    }

    private boolean extractBooleanOrDefault(final Boolean value) {
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        return value != null ? value : false;</span>
    }

    private String extractLaunchYear(final NagerHolidayResponse response) {
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        return response.launchYear() != null ? String.valueOf(response.launchYear()) : null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>